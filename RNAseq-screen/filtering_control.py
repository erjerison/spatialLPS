import numpy as np
import pandas as pd
import scanpy as sc
import matplotlib.pylab as pt
import numpy

data_path = '/Users/ejerison/Dropbox/zfish_lps_phases/single_cell/seq_11242021_output/Control/'
input_file = data_path + 'Control_counts_cont_scores.h5ad.gz' ###Loom file generated by load_and_estimate_quality2.Rmd
output_file = data_path + 'Control_counts_filtered.h5ad.gz'

sc.settings.verbosity = 3             # verbosity: errors (0), warnings (1), info (2), hints (3)
sc.logging.print_header()
sc.settings.set_figure_params(dpi=80, facecolor='white')

adata = sc.read_h5ad(input_file)

####Reset the .X matrix to the raw counts

adata.X = adata.layers['raw'].copy()

print(adata.var_names)

adata.var['mt'] = adata.var_names.str.startswith('mt-')  # annotate the group of mitochondrial genes as 'mt'
sc.pp.calculate_qc_metrics(adata, qc_vars=['mt'], percent_top=None, log1p=False, inplace=True)

print(adata)
sc.pl.scatter(adata, x='decontX_scores',y='pct_counts_mt',save='decontX_v_pct_mt.pdf')
sc.pl.scatter(adata, x='decontX_scores',y='doublet_score',save='decontX_v_doublet.pdf')
sc.pl.scatter(adata, x='doublet_score',y='pct_counts_mt',save='doublet_v_pct_mt')

pt.figure()
pt.hist(adata.obs['decontX_scores'].values,log=True,bins=numpy.arange(0,1,.02))
pt.savefig('figures/decontX_score_hist.pdf')
pt.figure()
pt.hist(adata.obs['doublet_score'].values,log=True,bins=numpy.arange(0,1,.02))
pt.savefig('figures/doublet_score_hist.pdf')

####Take a look at cell clusters generated with and without filtering and decontX correction

sc.pp.filter_genes(adata, min_cells=10)

adata = adata[adata.obs.pct_counts_mt < 12, :] ###filter on fraction of mitochondrial reads. currently we are not going to filter on read count
sc.pp.normalize_total(adata, target_sum=1e4)
sc.pp.log1p(adata)
sc.pp.highly_variable_genes(adata, min_mean=0.0125, max_mean=3, min_disp=0.5)
sc.pl.highly_variable_genes(adata)

sc.tl.pca(adata, svd_solver='arpack')
sc.pp.neighbors(adata, n_neighbors=10, n_pcs=50)

sc.tl.umap(adata)
sc.tl.leiden(adata)
sc.pl.umap(adata, color=['leiden','decontX_scores','doublet_score','and2','krt4','prss1'],save='control_umap1_with_doublet_predictions.pdf')

###Filter more aggressively and recalculate

adata = adata[adata.obs.doublet_score < .3,:]
adata = adata[adata.obs.decontX_scores < .5,:]

print(adata)

sc.pp.highly_variable_genes(adata, min_mean=0.0125, max_mean=3, min_disp=0.5)
sc.pl.highly_variable_genes(adata)

sc.tl.pca(adata, svd_solver='arpack')
sc.pp.neighbors(adata, n_neighbors=10, n_pcs=50)

sc.tl.umap(adata)
sc.tl.leiden(adata)
sc.pl.umap(adata, color=['leiden','decontX_scores','doublet_score','and2','krt4','prss1'],save='control_umap2_with_contaminant_filtered.pdf')

###reset adata.X to be the decontX matrix and then calculate umap

adata.X = adata.layers['decontX_counts'].copy()
adata = adata[adata.obs.pct_counts_mt < 12, :]
adata = adata[adata.obs.doublet_score < .3,:]
adata = adata[adata.obs.decontX_scores < .5,:]

sc.pp.normalize_total(adata, target_sum=1e4)
sc.pp.log1p(adata)
sc.pp.highly_variable_genes(adata, min_mean=0.0125, max_mean=3, min_disp=0.5)
sc.pl.highly_variable_genes(adata)

sc.tl.pca(adata, svd_solver='arpack')
sc.pp.neighbors(adata, n_neighbors=10, n_pcs=50)

sc.tl.umap(adata)
sc.tl.leiden(adata)
sc.pl.umap(adata, color=['leiden','decontX_scores','doublet_score','and2','krt4','prss1'],save='control_umap1_decontX_counts.pdf')

adata.write(output_file)
